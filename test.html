<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        canvas {
            border: 1px solid #000;
        }
    </style>
    <title>Interactive Shapes</title>
</head>
<body>
    <canvas id="canvas" width="500" height="500"></canvas>
    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        
        let circles = [
            { x: 100, y: 100, radius: 30, selected: false, hp: 100, maxHp: 100, attack: 10 },
            { x: 200, y: 300, radius: 20, selected: false, hp: 150, maxHp: 150, attack: 5 },
            { x: 400, y: 200, radius: 25, selected: false, hp: 80, maxHp: 80, attack: 8 }
        ];
        let square = { x: 200, y: 200, size: 60, selected: false, hp: 200, maxHp: 200, visible: true };
        let isDragging = false;
        let targetX = circles[0].x;
        let targetY = circles[0].y;
        let selectedCircles = [];
        
        canvas.addEventListener("mousedown", (e) => {
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top;
            
            if (e.shiftKey) { // Maintenir Shift pour sélectionner plusieurs ronds
                selectedCircles = circles.filter(circle => pointInCircle(mouseX, mouseY, circle));
            } else {
                selectedCircles = circles.filter(circle => pointInCircle(mouseX, mouseY, circle));
                if (e.button === 2 && selectedCircles.length > 0) {
                    targetX = mouseX;
                    targetY = mouseY;
                    return;
                }
            }
            
            isDragging = true;
        });
        
        canvas.addEventListener("mouseup", () => {
            isDragging = false;
        });
        
        canvas.addEventListener("mousemove", (e) => {
            if (isDragging) {
                const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - canvas.getBoundingClientRect().top;
                
                for (const circle of selectedCircles) {
                    circle.x = mouseX;
                    circle.y = mouseY;
                }
            }
        });
        
        canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            
            if (selectedCircles.length > 0 && square.selected) {
                for (const circle of selectedCircles) {
                    circle.x = square.x + square.size / 2;
                    circle.y = square.y + square.size / 2;
                }
            }
        });
        
        function pointInCircle(x, y, circle) {
            const dx = x - circle.x;
            const dy = y - circle.y;
            return dx * dx + dy * dy <= circle.radius * circle.radius;
        }
        
        function pointInSquare(x, y, square) {
            return x >= square.x && x <= square.x + square.size &&
                   y >= square.y && y <= square.y + square.size;
        }
        
        function moveCirclesTowardsTarget() {
            for (const circle of selectedCircles) {
                const dx = targetX - circle.x;
                const dy = targetY - circle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 1) {
                    const speed = 2;
                    circle.x += dx * speed / distance;
                    circle.y += dy * speed / distance;
                }
            }
        }
        
        function updateSquareHP() {
            for (const circle of selectedCircles) {
                if (pointInSquare(circle.x, circle.y, square)) {
                    square.hp -= circle.attack;
                    if (square.hp <= 0) {
                        square.hp = 0;
                        square.visible = false;
                    }
                }
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            moveCirclesTowardsTarget();
            updateSquareHP();
            
            for (const circle of circles) {
                ctx.fillStyle = circle.selected ? "blue" : "black";
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = "black";
                ctx.font = "14px Arial";
                ctx.fillText(`HP: ${circle.hp}`, circle.x - 20, circle.y - circle.radius - 10);
            }
            
            if (square.visible) {
                ctx.fillStyle = square.selected ? "red" : "black";
                ctx.fillRect(square.x, square.y, square.size, square.size);
                
                ctx.fillStyle = "green";
                ctx.fillRect(square.x, square.y - 10, (square.hp / square.maxHp) * square.size, 5);
                
                ctx.fillStyle = "black";
                ctx.font = "14px Arial";
                ctx.fillText(`HP: ${square.hp}`, square.x, square.y - 15);
            }
        }
        
        setInterval(draw, 10); // Mise à jour du dessin chaque 10 millisecondes
        
    </script>
</body>
</html>
